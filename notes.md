# Pydantic-модели для аннотации типов в FastAPI
Pydantic является Python-библиотекой для выполнения валидации данных.

Вы объявляете «форму» данных как классы с атрибутами.

И каждый атрибут имеет тип.

Затем вы создаете экземпляр этого класса с некоторыми значениями, и он проверяет значения, преобразует их в соответствующий тип (если все верно) и предоставляет вам объект со всеми данными.

Пример кода:
```python
from datetime import datetime
from typing import List, Union

from pydantic import BaseModel


# создаём модель данных, которая обычно расположена в файле models.py
class User(BaseModel):
    id: int
    name: str = "John Doe"
    signup_ts: Union[datetime, None] = None
    friends: List[int] = []

# Внешние данные, имитирует входящий JSON
external_data = {
    "id": "123",
    "signup_ts": "2017-06-01 12:22",
    "friends": [1, "2", b"3"],
}
# имитируем распаковку входящих данных в коде приложения
user = User(**external_data)
print(user)
# > User id=123 name='John Doe' signup_ts=datetime.datetime(2017, 6, 1, 12, 22) friends=[1, 2, 3]
print(user.id)
# > 123
```
С <b>FastAPI</b> вы объявляете параметры с аннотациями типов и получаете:

* Поддержку редактора.
* Проверки типов.

...и FastAPI использует тот же механизм для:

Определения требований: из параметров пути запроса, параметров запроса, заголовков, зависимостей и т.д.
Преобразования данных: от запроса к нужному типу.
Валидации данных: исходя из каждого запроса:
Генерации автоматических ошибок, возвращаемых клиенту, когда данные не являются корректными.
Документирования API с использованием OpenAPI: который затем используется пользовательскими интерфейсами автоматической интерактивной документации.
Еще пример кода:
```python
from datetime import date
from pydantic import BaseModel

# Объявляем параметр user_id с типом `str`
# и получаем поддержку проверки типов данных редактора (IDE) внутри функции
def main(user_id: str):
    return user_id


# Модель Pydantic - ещё один пример создания
class User(BaseModel):
    id: int
    name: str
    joined: date
```    
Соответственно моделька User потом может быть использована так (для создания объектов юзера и их использования в программе, в частности при получении данных в JSON-запросе и их распаковки в переменные внутри соответствующих функций-обработчиков):
```python
my_user: User = User(id=3, name="John Doe", joined="2018-07-19")

second_user_data = {
    "id": 4,
    "name": "Mary",
    "joined": "2018-11-30",
}

my_second_user: User = User(**second_user_data)
```
Давайте рассмотрим пример реального использования Pydantic-модели.
```python
from fastapi import FastAPI
from pydantic import BaseModel


app = FastAPI()

class User(BaseModel):
    username: str
    message: str
    
@app.post("/")
async def root(user: User):
    '''тут мы можем с переменной user, которая в себе содержит объект класса User с соответствующими полями (и указанными типами), делать любую логику
    - например, мы можем сохранить информацию в базу данных
    - или передать их в другую функцию
    - или другое'''
    print(f'Мы получили от юзера {user.username} такое сообщение: {user.message}') # тут мы просто выведем полученные данные на экран в отформатированном варианте
    return user # или можем вернуть обратно полученные данные, как символ того, что данные получили, или другая логика на ваш вкус

```
Обращу внимание, что при отправке POST-запроса с JSON-ом по корневому адресу, Pydantic автоматически проверит соответствие входных параметров объявленной модели, и вернёт ошибку, если что-то не будет соответствовать.

Пример валидного (корректного) POST-запроса в формате JSON:
```
{
  "username": "Vasya",
  "message": "I am BATMAN"
}
```
Примеры невалидного запроса, которые выдадут автоматическую ошибку от сервера о не корректности полученных данных:
```
{
  1: 12345
}
```
{
    "username": "john_doe",
    "message": false
}
```
{
    "username": "vasilisa"
}
```
Надеемся понятно зачем проверять входные данные, но если не очень, то поясним: вы ожидаете, что придут определённые данные определённого формата (например, сохраняете в БД, в которой у полей всегда указывается тип данных - VARCHAR (255) NOT NULL, допустим), а вам пытаются подсунуть либо неполные данные, либо другого формата (ожидаете сообщение message с типом "строка", а приходит вредоносный файл в байтах).

Или ещё пример, вы делаете API по возведению в квадрат числа, и ожидаете, что придёт int или float, чтобы потом возвести его в квадрат и вернуть результат. А вам приходит строка или None. При попытке возвести их в квадрат ваш API сломается и станет недоступен для всех остальных.

Тоже самое произойдёт, если вы ожидаете массив из 5 элементов, а вам приходит массив из трех. Пытаетесь обратиться к 5-му элементу и выпадаете за границу массива. Или вы делаете API погоды и ждёте, что во входящем словаре будет город. Пытаетесь его извлечь оттуда (но не через get() метод, а напрямую, аля request["city"]), и программа валится из-за попытки извлечь несуществующий элемент. Вот чтобы программа отработала не сломавшись именно так, как вы ожидаете, и нужна проверка типов.

# Определение конечной точки
Конечная точка API — это URL-адрес сервера или службы. В разработке API конечные точки на жаргоне ещё именуются "ручками". Соответственно у API можно дёргать разные ручки разными способами для получения различных данных / выполнения различных действий.

В FastAPI вы определяете конечные точки с помощью функций Python, оформленных HTTP-методами, такими как `@app.get()` для обработки запросов GET, `@app.post()` для запросов POST и так далее. Эти функции представляют собой логику обработки входящих запросов и генерации ответов. Они будут рассмотрены позднее в этом курсе. 

Коротенький пример get и post ручек:
```python
from fastapi import FastAPI


app = FastAPI()

fake_db = [{"username": "vasya", "user_info": "любит колбасу"}, {"username": "katya", "user_info": "любит петь"}]

@app.get('/users') # маршрут GET для ПОЛУЧЕНИЯ каких-то данных с сервера
async def get_all_users():
    return fake_db
    
@app.post('/add_user') # маршрут POST для отправления какой-то информации на сервер
async def add_user(username: str, user_info: str): # принимает два query-параметра, про которые будет рассказано дальше в этом уроке (это не типичный пример пост-запроса)
    fake_db.append({"username": username, "user_info": user_info})
    return {"message": "юзер успешно добавлен в базу данных"}
```
П.С. в данном примере мы передаем в пост-запросе параметры необычным способом - как query-параметры (так можно делать, но так не принято; обычно через POST-запрос данные передаются в теле запроса, и обычно в формате JSON). Не пугайтесь, если пока не понятно. Дальше по курсу расскажем и правильный способ отправки и обработки - покажем :)

# Обработка и проверка http запросов
## Методы HTTP запроса
<b>HTTP</b> определяет множество методов запроса, которые указывают, какое желаемое действие выполнится для данного ресурса. Несмотря на то, что их названия могут быть существительными, эти методы запроса иногда называются HTTP глаголами. Каждый реализует свою семантику, но каждая группа команд разделяет общие свойства: так, методы могут быть безопасными, идемпотентными или кешируемыми.

<b>GET</b> - Метод GET запрашивает представление ресурса. Запросы с использованием этого метода могут только извлекать данные.\
<b>HEAD</b> - запрашивает ресурс так же, как и метод GET, но без тела ответа.\
<b>POST</b> - используется для отправки сущностей к определённому ресурсу. Часто вызывает изменение состояния или какие-то побочные эффекты на сервере.\
<b>PUT</b> - заменяет все текущие представления ресурса данными запроса.\
<b>DELETE</b> - удаляет указанный ресурс.\
<b>CONNECT</b> - устанавливает "туннель" к серверу, определённому по ресурсу.\
<b>OPTIONS</b> - используется для описания параметров соединения с ресурсом.\
<b>TRACE</b> - выполняет вызов возвращаемого тестового сообщения с ресурса.\
<b>PATCH</b> - используется для частичного изменения ресурса.

## Обработка загрузки файлов
FastAPI поддерживает обработку загрузки файлов как части запроса. Вы можете использовать класс `File` из модуля `fastapi`, чтобы определить конечную точку загрузки файла и получить доступ к загруженным файлам в вашей функции роута.

Пример кода:
```python
from typing import Annotated
from fastapi import FastAPI, File, UploadFile

app = FastAPI()


@app.post("/files/")
async def create_file(file: Annotated[bytes, File()]):
    return {"file_size": len(file)}


@app.post("/uploadfile/")
async def create_upload_file(file: UploadFile):
    return {"filename": file.filename}
```
Разница между File и UploadFile в том, что File загружает только содержимое файла, а UploadFile загружает также метаинформацию вместе с самим содержимым.

## Обработка параметров запроса
Параметры запроса являются неотъемлемой частью построения API. FastAPI предоставляет простой способ обработки параметров запроса, определяя их в качестве аргументов функции в ваших функциях маршрутизации.
```python
from fastapi import FastAPI

app = FastAPI()

fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]

@app.get("/items/")
async def read_item(skip: int = 0, limit: int = 10):
    return fake_items_db[skip : skip + limit]
```
Query-параметры представляют из себя набор пар ключ-значение, которые идут после знака ? в URL-адресе, разделенные символами & (дополнительно можете прочитать про импорт класса Query из fastapi). 

Например, в этом URL-адресе: 
http://127.0.0.1:8000/items/?skip=0&limit=10

# Асинхронные обработчики маршрутов и фоновые задачи
## Введение в асинхронные обработчики
Чтобы создать асинхронный обработчик маршрута в FastAPI, мы используем синтаксис `async def`. Асинхронный обработчик маршрута может содержать выражения `await`, указывающие точки, в которых функция может приостановить выполнение других задач, пока она ожидает завершения асинхронной операции, такой как запрос к базе данных или HTTP-запрос.

Асинхронные обработчики маршрутов особенно полезны для обработки задач, связанных с вводом-выводом (I-O Bound), таких как выполнение сетевых запросов, чтение и запись файлов или выполнение запросов к базе данных. Вместо последовательного ожидания завершения каждой операции ввода-вывода асинхронные обработчики маршрутов могут инициировать несколько операций ввода-вывода одновременно, позволяя приложению выполнять другие задачи в ожидании завершения операций ввода-вывода.
## Фоновые задачи в FastAPI
FastAPI также поддерживает фоновые задачи, которые представляют собой функции, выполняемые после отправки ответа клиенту. Фоновые задачи полезны для обработки задач, которые не должны блокировать основной цикл запроса-ответа, таких как отправка электронных писем, обновление аналитики или выполнение дополнительной неблокирующей обработки.
Чтобы использовать фоновые задачи в FastAPI, вы можете определить функцию фоновой задачи (с использованием класса BackgroundTasks) и включить ее в качестве параметра в обработчик маршрута.

Пример:
```python
from fastapi import BackgroundTasks, FastAPI

app = FastAPI()


def write_notification(email: str, message=""):
    with open("log.txt", mode="w") as email_file:
        content = f"notification for {email}: {message}"
        email_file.write(content)


@app.post("/send-notification/{email}")
async def send_notification(email: str, background_tasks: BackgroundTasks):
    background_tasks.add_task(write_notification, email, message="some notification")
    return {"message": "Notification sent in the background"}
```

# Параметры Cookie
Вы можете задать параметры Cookie таким же способом, как Query и Path параметры.

FastAPI поддерживает три типа файлов cookie:

а) Обычные файлы cookie: Это стандартные файлы cookie, которые хранятся на стороне клиента и отправляются обратно на сервер при каждом запросе. Обычные файлы cookie широко используются для различных целей, таких как управление сеансами и пользовательскими настройками.

б) Защищенные файлы cookie: Защищенные файлы cookie - это зашифрованные файлы cookie, которые обеспечивают дополнительный уровень безопасности. Под защищенными куками мы имеем ввиду куки, в которых установлен флаг Secure, который говорит браузеру, что эти куки можно передавать только по SSL-соединению.

Примечание: рекомендуем прочитать про XSS-атаки, и дополнительную защиту куков при помощи установки флага HttpOnly, чтобы гарантировать, что данные файлов cookie остаются конфиденциальными и не могут быть использованы злоумышленниками с использованием внедрения вредоносного Javascript'а на сайтах.

c) Подписанные файлы cookie: Подписанные файлы cookie - это файлы cookie, которые содержат подпись для проверки их подлинности. Они гарантируют, что данные cookie-файлов не были изменены клиентом с тех пор, как они были установлены сервером.

Для доступа к кукам сначала импортируйте класс Cookie из fastapi. Затем объявляйте параметры cookie, используя ту же структуру, что и с Path и Query.

```python
from fastapi import Cookie, FastAPI

app = FastAPI()


@app.get("/items/")
async def read_items(ads_id: str | None = Cookie(default=None)):
    return {"ads_id": ads_id}
```
## Доступ к файлам cookie
FastAPI упрощает доступ к файлам cookie в запросе. Вы можете извлекать данные cookie и работать с ними в своих обработчиках маршрутов точно так же, как с любыми другими данными.

Для получения куки на сервере применяется класс fastapi.Cookie
```python
from fastapi import FastAPI, Cookie
 
app = FastAPI()
 
@app.get("/")
def root(last_visit = Cookie()):
    return  {"last visit": last_visit}
```
## Установка файлов cookie
В FastAPI вы можете установить файлы cookie в ответе, используя метод `set_cookie` в параметре Response. Этот метод позволяет вам определить имя файла cookie, значение и дополнительные параметры, такие как домен, путь, срок действия и параметры безопасности.

from fastapi import FastAPI, Response
from datetime import datetime
```python 
app = FastAPI()
 
@app.get("/")
def root(response: Response):
    now = datetime.now().strftime("%d/%m/%Y, %H:%M:%S")   # получаем текущую дату и время
    response.set_cookie(key="last_visit", value=now)
    return  {"message": "куки установлены"}
```
## Прочие возможности при работе с cookie
Вы можете указать время истечения срока действия файла cookie, используя параметр "expires", или установить максимальный возраст, используя параметр "max_age". Это помогает контролировать срок службы файлов cookie и эффективно управлять данными сеанса.
FastAPI предоставляет простой способ удалить файлы cookie, установив время их истечения в прошлом. Это дает указание клиенту удалить файл cookie из своего хранилища.
Также у класса Response есть метод delete_cookie, который принимает в качестве аргумента строку (наименование куки) и удаляет ее на стороне клиента.

Для примера:
```python
@router.post("/logout", status_code=204)
async def logout_user(response: Response):
    response.delete_cookie("example_access_token")
```
Под капотом, этот метод вызывает метод set_cookie и устанавливает атрибутам max_age и expires значение 0.

На этом данный урок заканчивается. Давайте продолжим наше путешествие по созданию мощных и безопасных API-интерфейсов с помощью FastAPI! 