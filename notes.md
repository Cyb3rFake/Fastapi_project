# Pydantic-модели для аннотации типов в FastAPI
Pydantic является Python-библиотекой для выполнения валидации данных.

Вы объявляете «форму» данных как классы с атрибутами.

И каждый атрибут имеет тип.

Затем вы создаете экземпляр этого класса с некоторыми значениями, и он проверяет значения, преобразует их в соответствующий тип (если все верно) и предоставляет вам объект со всеми данными.

Пример кода:
```python
from datetime import datetime
from typing import List, Union

from pydantic import BaseModel


# создаём модель данных, которая обычно расположена в файле models.py
class User(BaseModel):
    id: int
    name: str = "John Doe"
    signup_ts: Union[datetime, None] = None
    friends: List[int] = []

# Внешние данные, имитирует входящий JSON
external_data = {
    "id": "123",
    "signup_ts": "2017-06-01 12:22",
    "friends": [1, "2", b"3"],
}
# имитируем распаковку входящих данных в коде приложения
user = User(**external_data)
print(user)
# > User id=123 name='John Doe' signup_ts=datetime.datetime(2017, 6, 1, 12, 22) friends=[1, 2, 3]
print(user.id)
# > 123
```
С <b>FastAPI</b> вы объявляете параметры с аннотациями типов и получаете:

* Поддержку редактора.
* Проверки типов.

...и FastAPI использует тот же механизм для:

Определения требований: из параметров пути запроса, параметров запроса, заголовков, зависимостей и т.д.
Преобразования данных: от запроса к нужному типу.
Валидации данных: исходя из каждого запроса:
Генерации автоматических ошибок, возвращаемых клиенту, когда данные не являются корректными.
Документирования API с использованием OpenAPI: который затем используется пользовательскими интерфейсами автоматической интерактивной документации.
Еще пример кода:
```python
from datetime import date
from pydantic import BaseModel

# Объявляем параметр user_id с типом `str`
# и получаем поддержку проверки типов данных редактора (IDE) внутри функции
def main(user_id: str):
    return user_id


# Модель Pydantic - ещё один пример создания
class User(BaseModel):
    id: int
    name: str
    joined: date
```    
Соответственно моделька User потом может быть использована так (для создания объектов юзера и их использования в программе, в частности при получении данных в JSON-запросе и их распаковки в переменные внутри соответствующих функций-обработчиков):
```python
my_user: User = User(id=3, name="John Doe", joined="2018-07-19")

second_user_data = {
    "id": 4,
    "name": "Mary",
    "joined": "2018-11-30",
}

my_second_user: User = User(**second_user_data)
```
Давайте рассмотрим пример реального использования Pydantic-модели.
```python
from fastapi import FastAPI
from pydantic import BaseModel


app = FastAPI()

class User(BaseModel):
    username: str
    message: str
    
@app.post("/")
async def root(user: User):
    '''тут мы можем с переменной user, которая в себе содержит объект класса User с соответствующими полями (и указанными типами), делать любую логику
    - например, мы можем сохранить информацию в базу данных
    - или передать их в другую функцию
    - или другое'''
    print(f'Мы получили от юзера {user.username} такое сообщение: {user.message}') # тут мы просто выведем полученные данные на экран в отформатированном варианте
    return user # или можем вернуть обратно полученные данные, как символ того, что данные получили, или другая логика на ваш вкус

```
Обращу внимание, что при отправке POST-запроса с JSON-ом по корневому адресу, Pydantic автоматически проверит соответствие входных параметров объявленной модели, и вернёт ошибку, если что-то не будет соответствовать.

Пример валидного (корректного) POST-запроса в формате JSON:
```
{
  "username": "Vasya",
  "message": "I am BATMAN"
}
```
Примеры невалидного запроса, которые выдадут автоматическую ошибку от сервера о не корректности полученных данных:
```
{
  1: 12345
}
```
{
    "username": "john_doe",
    "message": false
}
```
{
    "username": "vasilisa"
}
```
Надеемся понятно зачем проверять входные данные, но если не очень, то поясним: вы ожидаете, что придут определённые данные определённого формата (например, сохраняете в БД, в которой у полей всегда указывается тип данных - VARCHAR (255) NOT NULL, допустим), а вам пытаются подсунуть либо неполные данные, либо другого формата (ожидаете сообщение message с типом "строка", а приходит вредоносный файл в байтах).

Или ещё пример, вы делаете API по возведению в квадрат числа, и ожидаете, что придёт int или float, чтобы потом возвести его в квадрат и вернуть результат. А вам приходит строка или None. При попытке возвести их в квадрат ваш API сломается и станет недоступен для всех остальных.

Тоже самое произойдёт, если вы ожидаете массив из 5 элементов, а вам приходит массив из трех. Пытаетесь обратиться к 5-му элементу и выпадаете за границу массива. Или вы делаете API погоды и ждёте, что во входящем словаре будет город. Пытаетесь его извлечь оттуда (но не через get() метод, а напрямую, аля request["city"]), и программа валится из-за попытки извлечь несуществующий элемент. Вот чтобы программа отработала не сломавшись именно так, как вы ожидаете, и нужна проверка типов.

# Определение конечной точки
Конечная точка API — это URL-адрес сервера или службы. В разработке API конечные точки на жаргоне ещё именуются "ручками". Соответственно у API можно дёргать разные ручки разными способами для получения различных данных / выполнения различных действий.

В FastAPI вы определяете конечные точки с помощью функций Python, оформленных HTTP-методами, такими как `@app.get()` для обработки запросов GET, `@app.post()` для запросов POST и так далее. Эти функции представляют собой логику обработки входящих запросов и генерации ответов. Они будут рассмотрены позднее в этом курсе. 

Коротенький пример get и post ручек:
```python
from fastapi import FastAPI


app = FastAPI()

fake_db = [{"username": "vasya", "user_info": "любит колбасу"}, {"username": "katya", "user_info": "любит петь"}]

@app.get('/users') # маршрут GET для ПОЛУЧЕНИЯ каких-то данных с сервера
async def get_all_users():
    return fake_db
    
@app.post('/add_user') # маршрут POST для отправления какой-то информации на сервер
async def add_user(username: str, user_info: str): # принимает два query-параметра, про которые будет рассказано дальше в этом уроке (это не типичный пример пост-запроса)
    fake_db.append({"username": username, "user_info": user_info})
    return {"message": "юзер успешно добавлен в базу данных"}
```
П.С. в данном примере мы передаем в пост-запросе параметры необычным способом - как query-параметры (так можно делать, но так не принято; обычно через POST-запрос данные передаются в теле запроса, и обычно в формате JSON). Не пугайтесь, если пока не понятно. Дальше по курсу расскажем и правильный способ отправки и обработки - покажем :)

# Обработка и проверка http запросов
## Методы HTTP запроса
<b>HTTP</b> определяет множество методов запроса, которые указывают, какое желаемое действие выполнится для данного ресурса. Несмотря на то, что их названия могут быть существительными, эти методы запроса иногда называются HTTP глаголами. Каждый реализует свою семантику, но каждая группа команд разделяет общие свойства: так, методы могут быть безопасными, идемпотентными или кешируемыми.

<b>GET</b> - Метод GET запрашивает представление ресурса. Запросы с использованием этого метода могут только извлекать данные.\
<b>HEAD</b> - запрашивает ресурс так же, как и метод GET, но без тела ответа.\
<b>POST</b> - используется для отправки сущностей к определённому ресурсу. Часто вызывает изменение состояния или какие-то побочные эффекты на сервере.\
<b>PUT</b> - заменяет все текущие представления ресурса данными запроса.\
<b>DELETE</b> - удаляет указанный ресурс.\
<b>CONNECT</b> - устанавливает "туннель" к серверу, определённому по ресурсу.\
<b>OPTIONS</b> - используется для описания параметров соединения с ресурсом.\
<b>TRACE</b> - выполняет вызов возвращаемого тестового сообщения с ресурса.\
<b>PATCH</b> - используется для частичного изменения ресурса.

## Обработка загрузки файлов
FastAPI поддерживает обработку загрузки файлов как части запроса. Вы можете использовать класс `File` из модуля `fastapi`, чтобы определить конечную точку загрузки файла и получить доступ к загруженным файлам в вашей функции роута.

Пример кода:
```python
from typing import Annotated
from fastapi import FastAPI, File, UploadFile

app = FastAPI()


@app.post("/files/")
async def create_file(file: Annotated[bytes, File()]):
    return {"file_size": len(file)}


@app.post("/uploadfile/")
async def create_upload_file(file: UploadFile):
    return {"filename": file.filename}
```
Разница между File и UploadFile в том, что File загружает только содержимое файла, а UploadFile загружает также метаинформацию вместе с самим содержимым.

## Обработка параметров запроса
Параметры запроса являются неотъемлемой частью построения API. FastAPI предоставляет простой способ обработки параметров запроса, определяя их в качестве аргументов функции в ваших функциях маршрутизации.
```python
from fastapi import FastAPI

app = FastAPI()

fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]

@app.get("/items/")
async def read_item(skip: int = 0, limit: int = 10):
    return fake_items_db[skip : skip + limit]
```
Query-параметры представляют из себя набор пар ключ-значение, которые идут после знака ? в URL-адресе, разделенные символами & (дополнительно можете прочитать про импорт класса Query из fastapi). 

Например, в этом URL-адресе: 
http://127.0.0.1:8000/items/?skip=0&limit=10

# Асинхронные обработчики маршрутов и фоновые задачи
## Введение в асинхронные обработчики
Чтобы создать асинхронный обработчик маршрута в FastAPI, мы используем синтаксис `async def`. Асинхронный обработчик маршрута может содержать выражения `await`, указывающие точки, в которых функция может приостановить выполнение других задач, пока она ожидает завершения асинхронной операции, такой как запрос к базе данных или HTTP-запрос.

Асинхронные обработчики маршрутов особенно полезны для обработки задач, связанных с вводом-выводом (I-O Bound), таких как выполнение сетевых запросов, чтение и запись файлов или выполнение запросов к базе данных. Вместо последовательного ожидания завершения каждой операции ввода-вывода асинхронные обработчики маршрутов могут инициировать несколько операций ввода-вывода одновременно, позволяя приложению выполнять другие задачи в ожидании завершения операций ввода-вывода.
## Фоновые задачи в FastAPI
FastAPI также поддерживает фоновые задачи, которые представляют собой функции, выполняемые после отправки ответа клиенту. Фоновые задачи полезны для обработки задач, которые не должны блокировать основной цикл запроса-ответа, таких как отправка электронных писем, обновление аналитики или выполнение дополнительной неблокирующей обработки.
Чтобы использовать фоновые задачи в FastAPI, вы можете определить функцию фоновой задачи (с использованием класса BackgroundTasks) и включить ее в качестве параметра в обработчик маршрута.

Пример:
```python
from fastapi import BackgroundTasks, FastAPI

app = FastAPI()


def write_notification(email: str, message=""):
    with open("log.txt", mode="w") as email_file:
        content = f"notification for {email}: {message}"
        email_file.write(content)


@app.post("/send-notification/{email}")
async def send_notification(email: str, background_tasks: BackgroundTasks):
    background_tasks.add_task(write_notification, email, message="some notification")
    return {"message": "Notification sent in the background"}
```

# Параметры Cookie
Вы можете задать параметры Cookie таким же способом, как Query и Path параметры.

FastAPI поддерживает три типа файлов cookie:

а) Обычные файлы cookie: Это стандартные файлы cookie, которые хранятся на стороне клиента и отправляются обратно на сервер при каждом запросе. Обычные файлы cookie широко используются для различных целей, таких как управление сеансами и пользовательскими настройками.

б) Защищенные файлы cookie: Защищенные файлы cookie - это зашифрованные файлы cookie, которые обеспечивают дополнительный уровень безопасности. Под защищенными куками мы имеем ввиду куки, в которых установлен флаг Secure, который говорит браузеру, что эти куки можно передавать только по SSL-соединению.

Примечание: рекомендуем прочитать про XSS-атаки, и дополнительную защиту куков при помощи установки флага HttpOnly, чтобы гарантировать, что данные файлов cookie остаются конфиденциальными и не могут быть использованы злоумышленниками с использованием внедрения вредоносного Javascript'а на сайтах.

c) Подписанные файлы cookie: Подписанные файлы cookie - это файлы cookie, которые содержат подпись для проверки их подлинности. Они гарантируют, что данные cookie-файлов не были изменены клиентом с тех пор, как они были установлены сервером.

Для доступа к кукам сначала импортируйте класс Cookie из fastapi. Затем объявляйте параметры cookie, используя ту же структуру, что и с Path и Query.

```python
from fastapi import Cookie, FastAPI

app = FastAPI()


@app.get("/items/")
async def read_items(ads_id: str | None = Cookie(default=None)):
    return {"ads_id": ads_id}
```
## Доступ к файлам cookie
FastAPI упрощает доступ к файлам cookie в запросе. Вы можете извлекать данные cookie и работать с ними в своих обработчиках маршрутов точно так же, как с любыми другими данными.

Для получения куки на сервере применяется класс fastapi.Cookie
```python
from fastapi import FastAPI, Cookie
 
app = FastAPI()
 
@app.get("/")
def root(last_visit = Cookie()):
    return  {"last visit": last_visit}
```
## Установка файлов cookie
В FastAPI вы можете установить файлы cookie в ответе, используя метод `set_cookie` в параметре Response. Этот метод позволяет вам определить имя файла cookie, значение и дополнительные параметры, такие как домен, путь, срок действия и параметры безопасности.

from fastapi import FastAPI, Response
from datetime import datetime
```python 
app = FastAPI()
 
@app.get("/")
def root(response: Response):
    now = datetime.now().strftime("%d/%m/%Y, %H:%M:%S")   # получаем текущую дату и время
    response.set_cookie(key="last_visit", value=now)
    return  {"message": "куки установлены"}
```
## Прочие возможности при работе с cookie
Вы можете указать время истечения срока действия файла cookie, используя параметр "expires", или установить максимальный возраст, используя параметр "max_age". Это помогает контролировать срок службы файлов cookie и эффективно управлять данными сеанса.
FastAPI предоставляет простой способ удалить файлы cookie, установив время их истечения в прошлом. Это дает указание клиенту удалить файл cookie из своего хранилища.
Также у класса Response есть метод delete_cookie, который принимает в качестве аргумента строку (наименование куки) и удаляет ее на стороне клиента.

Для примера:
```python
@router.post("/logout", status_code=204)
async def logout_user(response: Response):
    response.delete_cookie("example_access_token")
```
Под капотом, этот метод вызывает метод set_cookie и устанавливает атрибутам max_age и expires значение 0.
# Работа с заголовками запросов HTTPS

HTTP-заголовки - это метаданные, которые сопровождают HTTP-запрос или ответ. FastAPI позволяет вам получать доступ к заголовкам запросов и работать с ними для извлечения важной информации, такой как токены аутентификации, юзер-агенты и типы контента.

FastAPI позволяет вам получать доступ к заголовкам запросов (headers) в рамках ваших функций маршрутизации. Вы можете использовать заголовки для предоставления дополнительной информации или данных авторизации вашему API.
```python
from typing import Annotated

from fastapi import FastAPI, Header

app = FastAPI()


@app.get("/items/")
async def read_items(user_agent: Annotated[str | None, Header()] = None):
    return {"User-Agent": user_agent}
```
Разберём эту строчку: user_agent: Annotated[str | None, Header()] = None:

user_agent - это имя заголовка, который мы ищем;
при помощи Annotated мы задаём тип данных в заголовке (строка или None), соответственно другие типы не пройдут валидацию; 
также мы аннотируем формат тем, что указываем, что ожидаем именно заголовок (при помощи нашего класса Header) - то есть с помощью Annotated можно аннотировать переменную чем-то другим, кроме ее типа (например, строкой документации, чтобы какой-то гипотетический инструмент мог использовать ее для автоматического создания документации) или в нашем случае - классом, то есть мы говорим что тип - это строка или None, с одной стороны, но и заголовок - с другой;
в дополнение класс Header переводит наш snake_case у user_agent к формату заголовков ("User-Agent") - искать будет именно его;
и последнее - мы задаём значение заголовка по-умолчанию (=None ), и если заголовок не поступит в запросе, то внутри функции переменная user_agent будет равна None...мы можем задать здесь любое другое значение по умолчанию, если захотим.

## Автоматическое преобразование
Класс заголовок (Header) обладает небольшой дополнительной функциональностью в дополнение к тому, что предоставляют Path, Query и Cookie.

Большинство стандартных заголовков разделены символом "дефис", также известным как "символ минуса" (-).

Но переменная, подобная user-agent, недопустима в Python.

Таким образом, по умолчанию Header преобразует символы имен параметров из символа подчеркивания (_) в дефис (-) для извлечения и документирования заголовков.

Кроме того, HTTP-заголовки не чувствительны к регистру, поэтому вы можете объявить их в стандартном стиле Python (также известном как "snake_case").

Итак, вы можете использовать user_agent, как обычно, в коде Python, вместо того, чтобы использовать заглавные буквы как User_Agent или что-то подобное.

Если по какой-либо причине вам необходимо отключить автоматическое преобразование подчеркиваний в дефисы, установите параметр convert_underscores заголовка значение False.

## Повторяющиеся заголовки
В FastAPI возможно получение повторяющихся заголовков. Это означает, что один и тот же заголовок содержит несколько значений.

Вы можете определить эти случаи, используя список в объявлении типа. Вы получите все значения из дублирующегося заголовка в виде списка Python.

Например, чтобы объявить заголовок X-Token, который может появляться более одного раза, вы можете написать:
```python
from typing import Annotated

from fastapi import FastAPI, Header

app = FastAPI()


@app.get("/items/")
async def read_items(x_token: Annotated[list[str] | None, Header()] = None):
    return {"X-Token values": x_token}

```
Если вы взаимодействуете с этой операцией path, отправляя два HTTP-заголовка, таких как:
```
X-Token: foo
X-Token: bar
```
Ответ был бы таким:
```
{
    "X-Token values": [
        "bar",
        "foo"
    ]
}
```
## Доступ к заголовкам запросов
Для получения заголовков запроса применяется класс fastapi.Header. Например, получим заголовок User-Agent:
```python
from fastapi import FastAPI, Header
 
app = FastAPI()
 
@app.get("/")
def root(user_agent: str = Header()):
    return {"User-Agent": user_agent}
```
Для отправки заголовка в конструктор класса Response или его наследников параметру headers передается словарь, где ключи представляют названия заголовков:
```python
from fastapi import FastAPI, Response
 
app = FastAPI()
 
@app.get("/")
def root():
    data = "Hello from here"
    return Response(content=data, media_type="text/plain", headers={"Secret-Code" : "123459"})
```
Также можно задать заголовки с помощью атрибута headers, который есть у класса Response и его наследников. Данный атрибут фактически представляет словарь, где ключи - названия заголовков:

```python
from fastapi import FastAPI, Response

app = FastAPI()

@app.get("/")
def root(response: Response):
    response.headers["Secret-Code"] = "123459"
    return {"message": "Hello from my api"}
```
# Реализация базовой аутентификации в FastAPI
Чтобы реализовать базовую аутентификацию в FastAPI, нам необходимо выполнить следующие действия:

#### Шаг 1: Импорт зависимостей
```python
from fastapi import FastAPI, Depends, status, HTTPException
from pydantic import BaseModel
from fastapi.security import HTTPBasic, HTTPBasicCredentials
```
#### 2: Создайте приложение FastAPI и экземпляр 

```python
HTTPBasic
app = FastAPI()
security = HTTPBasic()
```
#### Шаг 3: Создайте модель пользователя
```python
class User(BaseModel):
    username: str
    password: str
```
#### добавим симуляцию базы данных в виде массива объектов юзеров
```python
USER_DATA = [User(**{"username": "user1", "password": "pass1"}), User(**{"username": "user2", "password": "pass2"})]
```
#### Шаг 4: Определите функцию аутентификации

def authenticate_user(credentials: HTTPBasicCredentials = Depends(security)):
    user = get_user_from_db(credentials.username)
    if user is None or user.password != credentials.password:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid credentials")
    return user

#### Шаг 5: Задайте логику получения информации о пользователе и его пароле

симуляционный пример:
```python
def get_user_from_db(username: str):
    for user in USER_DATA:
        if user.username == username:
            return user
    return None
```
Шаг 6: Защитите конечные точки с помощью аутентификации

```python
@app.get("/protected_resource/")
def get_protected_resource(user: User = Depends(authenticate_user)):
    return {"message": "You have access to the protected resource!", "user_info": user}
```
`Depends(authenticate_user)` - это пример внедрения зависимости (dependency injection), которые мы будем разбирать позднее в этом курсе. Для любознательных - можете заглянуть в комментарии, перескочить в урок 8.1 (8.1.2-8.1.3), или можете "поверить на слово", потом все встанет на свои места :)

В приведенном выше коде мы сначала импортируем необходимые зависимости, включая `FastAPI`, `HTTPBasic` и `HTTPBasicCredentials`. Затем мы создаем экземпляр `HTTPBasic` для использования для аутентификации. Мы определяем функцию `authenticate_user`, которая принимает `HTTPBasicCredentials` в качестве параметра, полученного из запроса. Эта функция проверяет учетные данные пользователя по базе данных и выдает ошибку HTTP 401 Unauthorized, если они недействительны.
Наконец, мы защищаем нашу конечную точку, добавляя функцию `authenticate_user` в качестве зависимости. Когда клиент отправляет запрос к конечной точке `/protected_resource/`, FastAPI сначала запустит функцию `authenticate_user` для проверки учетных данных пользователя, прежде чем выполнять основную функцию конечной точки.

# Что такое аутентификация на основе JWT?
JWT расшифровывается как веб-токен JSON, и это популярный метод реализации аутентификации в веб-приложениях. В отличие от базовой аутентификации, где серверу необходимо поддерживать состояние (обычно с помощью сессионных файлов cookie или токенов), JWT допускает аутентификацию без сохранения состояния. При настройке без сохранения состояния серверу не нужно хранить пользовательскую информацию, что делает его масштабируемым и подходящим для распределенных систем.
## Как работает JWT?
JWT - это объект JSON с цифровой подписью, который содержит утверждения о пользователе.

Утверждения - это утверждения о сущности (обычно о пользователе) и дополнительных данных.

JWT обычно состоит из трех частей, разделенных точками: заголовка, полезной нагрузки и подписи. Заголовок содержит метаданные о токене, такие как алгоритм подписи. Полезная нагрузка содержит утверждения, которые могут включать пользовательскую информацию и другие пользовательские данные. Подпись генерируется с использованием секретного ключа, известного только серверу.

Прочитать подробнее про JWT можно почитать тут:

https://habr.com/ru/articles/340146/

или в комментарии к этому шагу.
***
### Давайте посмотрим на пример создания и декодирования jwt-токена:
```python
import jwt # тут используем библиотеку PyJWT


# Секретный ключ для подписи и верификации токенов JWT
SECRET_KEY = "mysecretkey" # тут мы в реальной практике используем что-нибудь вроде команды `Bash (Linux) 'openssl rand -hex 32'`, и храним очень защищенно
ALGORITHM = "HS256" # плюс в реальной жизни мы устанавливаем "время жизни" токена

### Пример информации из БД
USERS_DATA = [
    {"username": "admin", "password": "adminpass"}
]\
#в реальной БД мы храним только ХЭШИ паролей (можете прочитать про библиотеку, к примеру, 'passlib') + соль (известная только нам добавка к паролю)
    

# Функция для создания JWT токена

def create_jwt_token(data: dict):
    return jwt.encode(data, SECRET_KEY, algorithm=ALGORITHM)#кодируем токен, передавая в него наш словарь с тем, что мы хотим там разместить


# Функция получения User'а по токену

def get_user_from_token(token: str):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM]) # декодируем токен
        return payload.get("sub") # тут мы идем в полезную нагрузку JWT-токена и возвращаем утверждение о юзере (subject); обычно там еще можно взять "iss" - issuer/эмитент, или "exp" - expiration time - время 'сгорания' и другое, что мы сами туда кладем
    except jwt.ExpiredSignatureError:
        pass # тут какая-то логика ошибки истечения срока действия токена
    except jwt.InvalidTokenError:
        pass # тут какая-то логика обработки ошибки декодирования токена


# Функция для получения пользовательских данных на основе имени пользователя
def get_user(username: str):
    for user in USERS_DATA:
        if user.get("username") == username:
            return user
    return None


# закодируем токен, внеся в него словарь с утверждением о пользователе
token = create_jwt_token({"sub": "admin"})

print(token) # можете посмотреть как выглядит токен jwt

# декодируем токен и излечем из него информацию о юзере, которую мы туда зашили
username = get_user_from_token(token)

print(username) # посмотрим, что возвращается то, что ожидаем

# и теперь пойдем в нашу базу данных искать такого юзера по юзернейму
current_user = get_user(username)

print(current_user) # удостоверимся, что нашелся тот, кто нужен
```
# Рабочий процесс JWT
Рабочий процесс аутентификации на основе JWT выглядит следующим образом:
> * Шаг 1: Аутентификация пользователя. Когда пользователь предоставляет действительные учетные данные (например, имя пользователя и пароль) для входа в систему, сервер проверяет их и генерирует JWT.
> * Шаг 2: Отправка JWT клиенту. Сервер отправляет JWT обратно клиенту (обычно в заголовке `Authorization` ответа) в качестве токена.
>* Шаг 3: Последующие запросы. Для всех последующих запросов, требующих аутентификации, клиент отправляет JWT в заголовке `Authorization`. Затем сервер проверяет подпись JWT с помощью секретного ключа. Если подпись действительна, сервер извлекает информацию о пользователе из утверждений и разрешает доступ к запрошенным ресурсам.

# Преимущества аутентификации на основе JWT
- Без сохранения состояния: серверу не нужно хранить информацию о сеансе, что делает его более масштабируемым для распределенных систем.
- Междоменность (кросс-доменность): Поскольку JWT обычно отправляются в заголовке "Авторизация" (Authorization), они хорошо работают с CORS (совместное использование ресурсов разных источников - Cross-Origin Resource Sharing) и могут использоваться в разных доменах.
- Пользовательские утверждения: Вы можете добавлять пользовательские утверждения в полезную нагрузку, обеспечивая гибкое хранение пользовательской информации.
# Соображения безопасности
Хотя аутентификация на основе JWT дает множество преимуществ, она также сопряжена с соображениями безопасности:
- Срок действия токена: установите подходящее время истечения срока действия токена, чтобы в случае его кражи (перехвата) злоумышленником время для причинения ущерба было ограничено.
- Используйте HTTPS: Всегда используйте HTTPS для шифрования связи между клиентом и сервером.
- Защита секретного ключа: Сохраняйте секретный ключ, используемый для подписи JWT, в безопасности. Компрометация ключа может привести к нарушениям безопасности.
- Размер токена: Помните о размере токена, поскольку он отправляется с каждым запросом. Избегайте включения конфиденциальных или ненужных данных в полезную нагрузку.

На следующем уроке мы рассмотрим управление доступом на основе ролей, которое позволяет детально управлять разрешениями в вашем приложении FastAPI.

<I>Примечание: Помните, что реализация аутентификации на основе JWT в производственной среде может потребовать дополнительных соображений, таких как механизмы отзыва токенов и обновления.</I>

# Пример более продвинутой защиты
Иногда нужно быстро сделать аутентификацию, используя имя пользователя и пароль (например, при разработке внутри компании). Для этого можно использовать возможности FastAPI по работе с OAuth2: 

```python
from fastapi import FastAPI, Depends
from fastapi.security import OAuth2PasswordBearer
from pydantic import BaseModel
import jwt


app = FastAPI()
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="login")


# Секретный ключ для подписи и верификации токенов JWT
SECRET_KEY = "mysecretkey" # тут мы в реальной практике используем что-нибудь вроде команды Bash (Linux) 'openssl rand -hex 32', и храним очень защищенно
ALGORITHM = "HS256" # плюс в реальной жизни мы устанавливаем "время жизни" токена

# Пример информации из БД
USERS_DATA = [
    {"username": "admin", "password": "adminpass"}
] # в реальной БД мы храним только ХЭШИ паролей (можете прочитать про библиотеку, к примеру, 'passlib') + соль (известная только нам добавка к паролю)

class User(BaseModel):
    username: str
    password: str
    

# Функция для создания JWT токена
def create_jwt_token(data: dict):
    return jwt.encode(data, SECRET_KEY, algorithm=ALGORITHM) # кодируем токен, передавая в него наш словарь с тем, что мы хотим там разместить


# Функция получения User'а по токену
def get_user_from_token(token: str = Depends(oauth2_scheme)):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM]) # декодируем токен
        return payload.get("sub") # тут мы идем в полезную нагрузку JWT-токена и возвращаем утверждение о юзере (subject); обычно там еще можно взять "iss" - issuer/эмитент, или "exp" - expiration time - время 'сгорания' и другое, что мы сами туда кладем
    except jwt.ExpiredSignatureError:
        pass # тут какая-то логика ошибки истечения срока действия токена
    except jwt.InvalidTokenError:
        pass # тут какая-то логика обработки ошибки декодирования токена


# Функция для получения пользовательских данных на основе имени пользователя
def get_user(username: str):
    for user in USERS_DATA:
        if user.get("username") == username:
            return user
    return None


# роут для аутентификации; так делать не нужно, это для примера - более корректный пример в следующем уроке
@app.post("/login")
async def login(user_in: User): 
    for user in USERS_DATA:
        if user.get("username") == user_in.username and user.get("password") == user_in.password:
            return {"access_token": create_jwt_token({"sub": user_in.username}), "token_type": "bearer"}
    return {"error": "Invalid credentials"}
    
# защищенный роут для получения информации о пользователе
@app.get("/about_me")
async def about_me(current_user: str = Depends(get_user_from_token)):
    user = get_user(current_user)
    if user:
        return user
    return {"error": "User not found"}
```
В этом примере мы создали два маршрута (login для получения JWT токена при предоставлении валидным данных, и защищенный about_me, который через зависимость проверяет существование юзера по токену).

OAuth2PasswordBearer проверяет схему направления токена (Authorization: Bearer) и возвращает токен. В нем мы передаем параметр tokenUrl, который указывает наш маршрут для создания токена (если не рассматривать наш тестовый пример, то обычно по такому маршруту зависимость с формой авторизации, то есть сразу оно перенаправит сразу на ввод пользовательских данных - либо вернёт токен, если его прислали, либо попросит ввести логин/пароль). Пример с формой - в следующем уроке. Сейчас наша задача пока понять логику работы. 

Такой пример улучшит защиту вашего приложения (по сравнению с базовой аутентификацией), хотя настоятельно рекомендуем вам не ограничиваться полученной в данном курсе информацией, а детально изучить технологии OAuth2 и JWT и прочее в разделах "Безопасность" обычного и продвинутого руководства пользователя FastAPI по адресам: https://fastapi.tiangolo.com/tutorial/security/  и https://fastapi.tiangolo.com/advanced/security/
