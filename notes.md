# Pydantic-модели для аннотации типов в FastAPI
Pydantic является Python-библиотекой для выполнения валидации данных.

Вы объявляете «форму» данных как классы с атрибутами.

И каждый атрибут имеет тип.

Затем вы создаете экземпляр этого класса с некоторыми значениями, и он проверяет значения, преобразует их в соответствующий тип (если все верно) и предоставляет вам объект со всеми данными.

Пример кода:
```python
from datetime import datetime
from typing import List, Union

from pydantic import BaseModel


# создаём модель данных, которая обычно расположена в файле models.py
class User(BaseModel):
    id: int
    name: str = "John Doe"
    signup_ts: Union[datetime, None] = None
    friends: List[int] = []

# Внешние данные, имитирует входящий JSON
external_data = {
    "id": "123",
    "signup_ts": "2017-06-01 12:22",
    "friends": [1, "2", b"3"],
}
# имитируем распаковку входящих данных в коде приложения
user = User(**external_data)
print(user)
# > User id=123 name='John Doe' signup_ts=datetime.datetime(2017, 6, 1, 12, 22) friends=[1, 2, 3]
print(user.id)
# > 123
```
С <b>FastAPI</b> вы объявляете параметры с аннотациями типов и получаете:

* Поддержку редактора.
* Проверки типов.

...и FastAPI использует тот же механизм для:

Определения требований: из параметров пути запроса, параметров запроса, заголовков, зависимостей и т.д.
Преобразования данных: от запроса к нужному типу.
Валидации данных: исходя из каждого запроса:
Генерации автоматических ошибок, возвращаемых клиенту, когда данные не являются корректными.
Документирования API с использованием OpenAPI: который затем используется пользовательскими интерфейсами автоматической интерактивной документации.
Еще пример кода:
```python
from datetime import date
from pydantic import BaseModel

# Объявляем параметр user_id с типом `str`
# и получаем поддержку проверки типов данных редактора (IDE) внутри функции
def main(user_id: str):
    return user_id


# Модель Pydantic - ещё один пример создания
class User(BaseModel):
    id: int
    name: str
    joined: date
```    
Соответственно моделька User потом может быть использована так (для создания объектов юзера и их использования в программе, в частности при получении данных в JSON-запросе и их распаковки в переменные внутри соответствующих функций-обработчиков):
```python
my_user: User = User(id=3, name="John Doe", joined="2018-07-19")

second_user_data = {
    "id": 4,
    "name": "Mary",
    "joined": "2018-11-30",
}

my_second_user: User = User(**second_user_data)
```
Давайте рассмотрим пример реального использования Pydantic-модели.
```python
from fastapi import FastAPI
from pydantic import BaseModel


app = FastAPI()

class User(BaseModel):
    username: str
    message: str
    
@app.post("/")
async def root(user: User):
    '''тут мы можем с переменной user, которая в себе содержит объект класса User с соответствующими полями (и указанными типами), делать любую логику
    - например, мы можем сохранить информацию в базу данных
    - или передать их в другую функцию
    - или другое'''
    print(f'Мы получили от юзера {user.username} такое сообщение: {user.message}') # тут мы просто выведем полученные данные на экран в отформатированном варианте
    return user # или можем вернуть обратно полученные данные, как символ того, что данные получили, или другая логика на ваш вкус

```
Обращу внимание, что при отправке POST-запроса с JSON-ом по корневому адресу, Pydantic автоматически проверит соответствие входных параметров объявленной модели, и вернёт ошибку, если что-то не будет соответствовать.

Пример валидного (корректного) POST-запроса в формате JSON:
```
{
  "username": "Vasya",
  "message": "I am BATMAN"
}
```
Примеры невалидного запроса, которые выдадут автоматическую ошибку от сервера о не корректности полученных данных:
```
{
  1: 12345
}
```
{
    "username": "john_doe",
    "message": false
}
```
{
    "username": "vasilisa"
}
```
Надеемся понятно зачем проверять входные данные, но если не очень, то поясним: вы ожидаете, что придут определённые данные определённого формата (например, сохраняете в БД, в которой у полей всегда указывается тип данных - VARCHAR (255) NOT NULL, допустим), а вам пытаются подсунуть либо неполные данные, либо другого формата (ожидаете сообщение message с типом "строка", а приходит вредоносный файл в байтах).

Или ещё пример, вы делаете API по возведению в квадрат числа, и ожидаете, что придёт int или float, чтобы потом возвести его в квадрат и вернуть результат. А вам приходит строка или None. При попытке возвести их в квадрат ваш API сломается и станет недоступен для всех остальных.

Тоже самое произойдёт, если вы ожидаете массив из 5 элементов, а вам приходит массив из трех. Пытаетесь обратиться к 5-му элементу и выпадаете за границу массива. Или вы делаете API погоды и ждёте, что во входящем словаре будет город. Пытаетесь его извлечь оттуда (но не через get() метод, а напрямую, аля request["city"]), и программа валится из-за попытки извлечь несуществующий элемент. Вот чтобы программа отработала не сломавшись именно так, как вы ожидаете, и нужна проверка типов.

# Определение конечной точки
Конечная точка API — это URL-адрес сервера или службы. В разработке API конечные точки на жаргоне ещё именуются "ручками". Соответственно у API можно дёргать разные ручки разными способами для получения различных данных / выполнения различных действий.

В FastAPI вы определяете конечные точки с помощью функций Python, оформленных HTTP-методами, такими как `@app.get()` для обработки запросов GET, `@app.post()` для запросов POST и так далее. Эти функции представляют собой логику обработки входящих запросов и генерации ответов. Они будут рассмотрены позднее в этом курсе. 

Коротенький пример get и post ручек:
```python
from fastapi import FastAPI


app = FastAPI()

fake_db = [{"username": "vasya", "user_info": "любит колбасу"}, {"username": "katya", "user_info": "любит петь"}]

@app.get('/users') # маршрут GET для ПОЛУЧЕНИЯ каких-то данных с сервера
async def get_all_users():
    return fake_db
    
@app.post('/add_user') # маршрут POST для отправления какой-то информации на сервер
async def add_user(username: str, user_info: str): # принимает два query-параметра, про которые будет рассказано дальше в этом уроке (это не типичный пример пост-запроса)
    fake_db.append({"username": username, "user_info": user_info})
    return {"message": "юзер успешно добавлен в базу данных"}
```
П.С. в данном примере мы передаем в пост-запросе параметры необычным способом - как query-параметры (так можно делать, но так не принято; обычно через POST-запрос данные передаются в теле запроса, и обычно в формате JSON). Не пугайтесь, если пока не понятно. Дальше по курсу расскажем и правильный способ отправки и обработки - покажем :)

# Обработка и проверка http запросов
## Методы HTTP запроса
<b>HTTP</b> определяет множество методов запроса, которые указывают, какое желаемое действие выполнится для данного ресурса. Несмотря на то, что их названия могут быть существительными, эти методы запроса иногда называются HTTP глаголами. Каждый реализует свою семантику, но каждая группа команд разделяет общие свойства: так, методы могут быть безопасными, идемпотентными или кешируемыми.

<b>GET</b> - Метод GET запрашивает представление ресурса. Запросы с использованием этого метода могут только извлекать данные.\
<b>HEAD</b> - запрашивает ресурс так же, как и метод GET, но без тела ответа.\
<b>POST</b> - используется для отправки сущностей к определённому ресурсу. Часто вызывает изменение состояния или какие-то побочные эффекты на сервере.\
<b>PUT</b> - заменяет все текущие представления ресурса данными запроса.\
<b>DELETE</b> - удаляет указанный ресурс.\
<b>CONNECT</b> - устанавливает "туннель" к серверу, определённому по ресурсу.\
<b>OPTIONS</b> - используется для описания параметров соединения с ресурсом.\
<b>TRACE</b> - выполняет вызов возвращаемого тестового сообщения с ресурса.\
<b>PATCH</b> - используется для частичного изменения ресурса.

## Обработка загрузки файлов
FastAPI поддерживает обработку загрузки файлов как части запроса. Вы можете использовать класс `File` из модуля `fastapi`, чтобы определить конечную точку загрузки файла и получить доступ к загруженным файлам в вашей функции роута.

Пример кода:
```python
from typing import Annotated
from fastapi import FastAPI, File, UploadFile

app = FastAPI()


@app.post("/files/")
async def create_file(file: Annotated[bytes, File()]):
    return {"file_size": len(file)}


@app.post("/uploadfile/")
async def create_upload_file(file: UploadFile):
    return {"filename": file.filename}
```
Разница между File и UploadFile в том, что File загружает только содержимое файла, а UploadFile загружает также метаинформацию вместе с самим содержимым.

## Обработка параметров запроса
Параметры запроса являются неотъемлемой частью построения API. FastAPI предоставляет простой способ обработки параметров запроса, определяя их в качестве аргументов функции в ваших функциях маршрутизации.
```python
from fastapi import FastAPI

app = FastAPI()

fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]

@app.get("/items/")
async def read_item(skip: int = 0, limit: int = 10):
    return fake_items_db[skip : skip + limit]
```
Query-параметры представляют из себя набор пар ключ-значение, которые идут после знака ? в URL-адресе, разделенные символами & (дополнительно можете прочитать про импорт класса Query из fastapi). 

Например, в этом URL-адресе:

 
http://127.0.0.1:8000/items/?skip=0&limit=10
